package br.edu.fesa.Conditional_Command_Parser.utils;

import br.edu.fesa.Conditional_Command_Parser.model.*;
import java.util.List;

/*
 * A recursive descent parser for constructing an abstract syntax tree (AST) from a list of tokens.
 *
 * <p>This parser implements a recursive descent algorithm for the grammar defined by the tokens. It
 * supports conditional statements (if/else), assignment statements, binary operations, and basic
 * arithmetic expressions. The parser maintains its current position and token to incrementally
 * consume the input tokens.
 */
public class RecursiveDescentParser {
  // List of tokens generated by the lexer.
  private final List<Token> tokens;
  // Current index position in the token list.
  private int currentPosition;
  // The current token under evaluation.
  private Token currentToken;

  /*
   * Constructs the parser with a list of tokens.
   *
   * @param tokens the list of tokens generated by the lexer.
   */
  public RecursiveDescentParser(List<Token> tokens) {
    this.tokens = tokens;
    this.currentPosition = 0;
    this.currentToken = tokens.get(0);
  }

  /* Advances the current position to the next token. */
  private void advance() {
    currentPosition++;
    if (currentPosition < tokens.size()) {
      currentToken = tokens.get(currentPosition);
    }
  }
  
  /*
   * Verifies that the current token matches the expected type and advances the token pointer.
   *
   * @param expected the expected token type.
   * @throws SyntaxException if the current token does not match the expected type.
   */
  private void eat(Token.Type expected) throws SyntaxException {
    if (currentToken.getType() == expected) {
      advance();
    } else {
      throw new SyntaxException(
          String.format(
              "Erro sintático [Linha %d, Coluna %d]: Esperado '%s' mas encontrado '%s'",
              currentToken.getLine(), currentToken.getColumn(), expected, currentToken.getType()));
    }
  }

  /*
   * Parses the entire input and returns the resulting abstract syntax tree.
   *
   * @return the root node of the AST.
   * @throws SyntaxException if any syntax error is detected during parsing.
   */
  public SyntaxNode parse() throws SyntaxException {
    // Start parsing from the starting symbol S and ensure the entire input is consumed.
    SyntaxNode result = parseS();
    eat(Token.Type.EOF); // Ensure that all tokens have been consumed.
    return result;
  }

  /*
   * Parses the starting symbol S.
   *
   * @return the AST node representing the parsed statement.
   * @throws SyntaxException if an unexpected token is encountered.
   */
  private SyntaxNode parseS() throws SyntaxException {
    // If the token indicates an 'if' statement, parse it accordingly.
    if (currentToken.getType() == Token.Type.IF) {
      return parseIfStatement();
    }
    // Otherwise, parse it as an assignment.
    return parseAssignment();
  }
  
    /*
   * Parses an if statement using the following structure:
   * <pre>
   *   if ( condition ) thenStatement else elseStatement
   * </pre>
   *
   * @return the AST node representing the if statement.
   * @throws SyntaxException if the expected tokens are not found.
   */
  private IfStatement parseIfStatement() throws SyntaxException {
    Token startToken = currentToken;
    eat(Token.Type.IF);
    eat(Token.Type.LPAREN);
    // Parse the condition expression within the parentheses.
    SyntaxNode condition = parseE();
    eat(Token.Type.RPAREN);
    // Parse the then branch statement.
    SyntaxNode thenBranch = parseS();
    eat(Token.Type.ELSE);
    // Parse the else branch statement.
    SyntaxNode elseBranch = parseS();

    return IfStatement.builder()
        .line(startToken.getLine())
        .column(startToken.getColumn())
        .condition(condition)
        .thenBranch(thenBranch)
        .elseBranch(elseBranch)
        .build();
  }

  /*
   * Parses an assignment statement with the structure:
   * <pre>
   *   identifier = expression
   * </pre>
   *
   * @return the AST node representing the assignment.
   * @throws SyntaxException if an unexpected token is encountered.
   */
  private Assignment parseAssignment() throws SyntaxException {
    Token idToken = currentToken;
    // Assumes that only identifiers are valid on the left-hand side of the assignment.
    eat(Token.Type.ID);
    eat(Token.Type.EQUALS);
    // Parse the right-hand side expression.
    SyntaxNode expression = parseE();

    return Assignment.builder()
        .line(idToken.getLine())
        .column(idToken.getColumn())
        .identifier(idToken.getValue())
        .expression(expression)
        .build();
  }

  /*
   * Parses an expression using the grammar for addition and subtraction.
   *
   * @return the AST node representing the expression.
   * @throws SyntaxException if an unexpected token is encountered.
   */
  private SyntaxNode parseE() throws SyntaxException {
    // Parse the first term.
    SyntaxNode node = parseT();
    // Continuously parse any following + or - operations.
    while (currentToken.getType() == Token.Type.PLUS
        || currentToken.getType() == Token.Type.MINUS) {
      Token opToken = currentToken;
      eat(opToken.getType());
      SyntaxNode right = parseT();
      node =
          BinOp.builder()
              .line(opToken.getLine())
              .column(opToken.getColumn())
              .operator(opToken.getValue())
              .left(node)
              .right(right)
              .build();
    }
    return node;
  }
  
    /*
   * Parses a term using the grammar for multiplication and division.
   *
   * @return the AST node representing the term.
   * @throws SyntaxException if an unexpected token is encountered.
   */
  private SyntaxNode parseT() throws SyntaxException {
    // Parse the first factor.
    SyntaxNode node = parseF();
    // Continuously parse any following * or / operations.
    while (currentToken.getType() == Token.Type.TIMES
        || currentToken.getType() == Token.Type.DIVIDE) {
      Token opToken = currentToken;
      eat(opToken.getType());
      SyntaxNode right = parseF();
      node =
          BinOp.builder()
              .line(opToken.getLine())
              .column(opToken.getColumn())
              .operator(opToken.getValue())
              .left(node)
              .right(right)
              .build();
    }
    return node;
  }

  /*
   * Parses a factor which can be an expression within parentheses, an identifier, or a number
   * literal.
   *
   * @return the AST node representing the factor.
   * @throws SyntaxException if the token does not match any valid factor.
   */
  private SyntaxNode parseF() throws SyntaxException {
    // Handle expressions within parentheses.
    if (currentToken.getType() == Token.Type.LPAREN) {
      eat(Token.Type.LPAREN);
      SyntaxNode node = parseE();
      eat(Token.Type.RPAREN);
      return node;
    }

    // Accept tokens of type ID or NUMBER.
    if (currentToken.getType() == Token.Type.ID || currentToken.getType() == Token.Type.NUMBER) {
      Token token = currentToken;
      eat(currentToken.getType());
      if (token.getType() == Token.Type.NUMBER) {
        return NumberLiteral.builder()
            .line(token.getLine())
            .column(token.getColumn())
            .value(token.getValue())
            .build();
      } else {
        return Identifier.builder()
            .line(token.getLine())
            .column(token.getColumn())
            .name(token.getValue())
            .build();
      }
    }

    // If none of the valid options match, throw an exception with detailed message.
    throw new SyntaxException(
        String.format(
            "Erro sintático [Linha %d, Coluna %d]: Esperado '(', 'id' ou 'number' mas encontrado"
                + " '%s'",
            currentToken.getLine(), currentToken.getColumn(), currentToken.getType()));
  }
}
